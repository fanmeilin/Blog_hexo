---
title: 剑指offer20 表示数值的字符串
tags: [剑指,有限状态机,idea]
categories: [剑指,有限状态机]
date: 2021-08-19 09:30:05
math: true
---

> 表示数值的字符串

## 题目
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。

**数值**（按顺序）可以分成以下几个部分：

1. 若干空格
2. 一个 小数 或者 整数
3. （可选）一个 'e' 或 'E' ，后面跟着一个 整数
4. 若干空格

**小数**（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（'+' 或 '-'）

2. 下述格式之一：

   1. 至少一位数字，后面跟着一个点 '.'
   2. 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
   3. 一个点 '.' ，后面跟着至少一位数字

**整数**（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（'+' 或 '-'）
2. 至少一位数字

部分**数值**列举如下：
- ["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"]

部分非数值列举如下：
- ["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"]

### 示例 1：

```
输入：s = "0"
输出：true

```

### 示例 2：

```
输入：s = "e"
输出：false

```
### 示例 3：

```
输入：s = "."
输出：false
```
### 示例 4：

```
输入：s = "    .1  "
输出：true
```

### 提示：

- 1 <= s.length <= 20
- s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，空格 ' ' 或者点 '.' 。

## 题解

### 解题思路

本题解决方案是有限状态自动机。根据字符类型和合法数值的特点，定义状态，再画出状态转移图。

#### 字符类型

空格:' '，数字:d，正负号:s，小数点:'.'，幂符号：e

#### 状态定义

从左到右可以定义为

   0.左边的`空格`

1. E之前的`正负号`
2. 小数点前的`数字`
3. 小数点，小数点之后的`数字`
4. 小数点前为空格，`小数点`，小数点后为数字
5. `幂符号`
6. 幂符号之后的`正负号`
7. 幂符号之后的`数字`
8. 结尾的`空格`

![](https://picture.mulindya.com/leetcode-offer20-pic1.png)

#### 结束状态

正常的结束状态有2，3，7，8

### 算法流程

#### 初始化

##### 1，状态转移表status

$states[i]$表示所处的状态，$i$为所处的状态表示，$states[i]$使用哈希表存储从i状态到可转移的状态；使用键值对来表示$(key,value)$：若输入$key$，可从状态$i$转移至状态$value$.

当前状态p：初始状态为0

##### 2，转移循环

还需要**记录字符类型**t，遍历字符串的每个字符c

- 当 c 为正负号时，执行 t = 's' ;
- 当 c 为数字时，执行 t = 'd' ;
- 当 c 为 e , E 时，执行 t = 'e' ;
- 当 c 为 . , 空格 时，执行 t = c （即用字符本身表示字符类型）;
- 否则，执行 t = '?' ，代表为不属于判断范围的非法字符，后续直接返回 false。

**终止条件**： 若字符类型 t不在哈希表  $states[p]$ 中，说明无法转移至下一状态，因此直接返回 False 。
**状态转移**： 状态 p 转移至 $states[p][t]$。

```python
class Solution:
    def isNumber(self, s: str) -> bool:
        states = [
            { ' ': 0, 's': 1, 'd': 2, '.': 4 }, # 0. start with 'blank'
            { 'd': 2, '.': 4 } ,                # 1. 'sign' before 'e'
            { 'd': 2, '.': 3, 'e': 5, ' ': 8 }, # 2. 'digit' before 'dot'
            { 'd': 3, 'e': 5, ' ': 8 },         # 3. 'digit' after 'dot'
            { 'd': 3 },                         # 4. 'digit' after 'dot' (‘blank’ before 'dot')
            { 's': 6, 'd': 7 },                 # 5. 'e'
            { 'd': 7 },                         # 6. 'sign' after 'e'
            { 'd': 7, ' ': 8 },                 # 7. 'digit' after 'e'
            { ' ': 8 }                          # 8. end with 'blank'
        ]
        p = 0                           # start with state 0
        for c in s:
            if '0' <= c <= '9': t = 'd' # digit
            elif c in "+-": t = 's'     # sign
            elif c in "eE": t = 'e'     # e or E
            elif c in ". ": t = c       # dot, blank
            else: t = '?'               # unknown
            if t not in states[p]: return False
            p = states[p][t]
        return p in (2, 3, 7, 8)

```

